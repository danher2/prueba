shell

TABLE="test"
LOG="expiration_update_log.csv"
EXP_DAYS=60

# Compute expiration epoch (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

# Initialize CSV log
echo "ID,ACCOUNTNUMBER,Status" > "$LOG"

NEXT_TOKEN=""
UPDATED=0

while :; do
  # 1) Scan for items missing 'expiration', output ID & ACCOUNT as text:
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration)" \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration)" \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If there’s nothing to update, inform and break
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Process each line (ID<TAB>ACCOUNTNUMBER)
  while read -r ID ACC; do
	ID=$(echo "$ID" | tr -d '\r\n[:space:]')
    ACC=$(echo "$ACC" | tr -d '\r\n[:space:]')
  
    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    echo "$ID,$ACC,Updated" >> "$LOG"
    ((UPDATED++))
  done <<< "$RAW_LIST"

  # 3) Get NextToken for pagination (AWS CLI v2)
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
    --filter-expression "attribute_not_exists(expiration)" \
    --projection-expression "ID" \
    --query "NextToken" \
    --output text)

  # AWS CLI outputs “None” or blank when there is no next token
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Only show the summary if we actually updated something
if (( UPDATED > 0 )); then
  echo
  echo "Update complete. $UPDATED records updated. See $LOG."
fi

===================================================================================================================

BAT

@echo off
setlocal enabledelayedexpansion

rem ── Configuration ─────────────
set "TABLE=test"
set "LOG=expiration_update_log.csv"
set /a EXP_DAYS=60

rem ── Compute expiration epoch (UTC now + EXP_DAYS)
for /f %%T in ('powershell -NoProfile -Command ^
  "(Get-Date).AddDays(%EXP_DAYS%).ToUniversalTime().Subtract([datetime]'1970-01-01').TotalSeconds|ForEach-Object {[int]$_}"') do (
  set "EXPIRATION=%%T"
)

rem ── Initialize CSV log
echo ID,ACCOUNTNUMBER,Status > "%LOG%"

rem ── Paging setup
set "NEXT_TOKEN="
set /a UPDATED=0

:PAGE_LOOP
  rem 1) Scan, filtering out items that already have 'expiration'
  if defined NEXT_TOKEN (
    set "SCAN_OPTS=--starting-token %NEXT_TOKEN%"
  ) else (
    set "SCAN_OPTS="
  )

  for /f "tokens=1,2" %%A in ('aws dynamodb scan --table-name %TABLE% ^
      --filter-expression "attribute_not_exists(expiration)" ^
      --projection-expression "ID,ACCOUNTNUMBER" ^
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" ^
      --output text %SCAN_OPTS%') do (
      
      set "ID=%%A"
      set "ACC=%%B"

      rem 2) Update expiration
      aws dynamodb update-item ^
        --table-name %TABLE% ^
        --key "{\"ID\":{\"S\":\"!ID!\"},\"ACCOUNTNUMBER\":{\"S\":\"!ACC!\"}}" ^
        --update-expression "SET expiration = :exp" ^
        --expression-attribute-values "{\":exp\":{\"N\":\"%EXPIRATION%\"}}" ^
        --return-values NONE

      echo !ID!,!ACC!,Updated>>"%LOG%"
      set /a UPDATED+=1
  )

  rem 3) Get the NextToken for pagination (AWS CLI v2)
  for /f %%T in ('aws dynamodb scan --table-name %TABLE% ^
      --filter-expression "attribute_not_exists(expiration)" ^
      --projection-expression "ID" ^
      --query "NextToken" ^
      --output text') do set "NEXT_TOKEN=%%T"

  if "%NEXT_TOKEN%"=="None" set "NEXT_TOKEN="
  if defined NEXT_TOKEN goto PAGE_LOOP

:END
echo.
echo Update complete. %UPDATED% records updated. See %LOG%.
endlocal


================================================================
sh

#!/usr/bin/env bash
set -euo pipefail

# ── Configuration ─────────────
TABLE="test"
LOG="expiration_update_log.csv"
EXP_DAYS=60

# NEW: set the values you want to filter on
BATCH_ID="yourBatchIdValue"
PCLM_TYPE="yourPclmTypeValue"

# Compute expiration epoch (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

# Initialize CSV log
echo "ID,ACCOUNTNUMBER,Status" > "$LOG"

NEXT_TOKEN=""
UPDATED=0

while :; do
  # 1) Scan for items missing 'expiration' AND matching batchID & PCLMType
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If there’s nothing to update, inform and break
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Process each line (ID<TAB>ACCOUNTNUMBER)
  while read -r ID ACC; do
    ID=$(echo "$ID" | tr -d '\r\n[:space:]')
    ACC=$(echo "$ACC" | tr -d '\r\n[:space:]')

    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    echo "$ID,$ACC,Updated" >> "$LOG"
    ((UPDATED++))
  done <<< "$RAW_LIST"

  # 3) Get NextToken for pagination (AWS CLI v2), with the same filter
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
    --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
    --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
    --projection-expression "ID" \
    --query "NextToken" \
    --output text)

  # AWS CLI outputs “None” or blank when there is no next token
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Only show the summary if we actually updated something
if (( UPDATED > 0 )); then
  echo
  echo "Update complete. $UPDATED records updated. See $LOG."
fi
=======================================================================================

#!/usr/bin/env bash
set -euo pipefail

# ── Configuration ─────────────
TABLE="test"
LOG="expiration_update_log.csv"
EXP_DAYS=60

# NEW: values to filter by
BATCH_ID="yourBatchIdValue"
PCLM_TYPE="yourPclmTypeValue"

# Compute expiration epoch (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

# Initialize CSV log
echo "ID,ACCOUNTNUMBER,Status" > "$LOG"

NEXT_TOKEN=""
UPDATED=0
PAGE=0

while :; do
  # ── Page counter & message ─────────────
  PAGE=$((PAGE+1))
  echo "▶ Scanning page $PAGE..."

  # 1) Scan for items missing 'expiration' and matching BatchID & PCLMType:
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If there’s nothing to update, inform and break
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Process each line (ID<TAB>ACCOUNTNUMBER)
  while read -r ID ACC; do
    ID=${ID//$'\r'/}
    ACC=${ACC//$'\r'/}

    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    echo "$ID,$ACC,Updated" >> "$LOG"
    ((UPDATED++))
  done <<< "$RAW_LIST"

  # 3) Get NextToken for pagination (AWS CLI v2), with same filter
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
    --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
    --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
    --projection-expression "ID" \
    --query "NextToken" \
    --output text)

  # AWS CLI outputs “None” or blank when there is no next token
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Only show the summary if we actually updated something
if (( UPDATED > 0 )); then
  echo
  echo "Processed $PAGE pages, updated $UPDATED records. See $LOG."
fi
=========================================================================================
#!/usr/bin/env bash
set -euo pipefail

# ── Configuration ─────────────
TABLE="test"
LOG="expiration_update_log.csv"
EXP_DAYS=60

# Filter values
BATCH_ID="yourBatchIdValue"
PCLM_TYPE="yourPclmTypeValue"

# Compute expiration epoch (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

# Initialize CSV log
echo "ID,ACCOUNTNUMBER,Status" > "$LOG"

NEXT_TOKEN=""
UPDATED=0
PAGE=0

while :; do
  # Increment page counter and show progress
  PAGE=$((PAGE+1))
  echo "▶ Scanning page $PAGE..."

  # 1) Scan for items missing 'expiration' and matching batchID & PCLMType
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If there’s nothing to update, inform and break
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Process each line (ID<TAB>ACCOUNTNUMBER), update and log
  while read -r ID ACC; do
    # Strip any stray carriage returns
    ID=${ID//$'\r'/}
    ACC=${ACC//$'\r'/}

    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    echo "$ID,$ACC,Updated" >> "$LOG"
    ((UPDATED++))
    # Live counter on the same line
    printf '\rRecords processed: %d' "$UPDATED"
  done <<< "$RAW_LIST"
  printf '\n'

  # 3) Get NextToken for pagination, with same filter
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
    --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
    --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
    --projection-expression "ID" \
    --query "NextToken" \
    --output text)

  # Break if no more pages
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Final summary
if (( UPDATED > 0 )); then
  echo
  echo "Processed $PAGE pages, updated $UPDATED records. See $LOG."
fi


=======================================================================================

#!/usr/bin/env bash
set -euo pipefail

# ── Configuration ─────────────
TABLE="test"
EXP_DAYS=60
PAGE_SIZE=1000              # max items to fetch per Scan “page”

# Filter values
BATCH_ID="yourBatchIdValue"
PCLM_TYPE="yourPclmTypeValue"

# Compute expiration epoch (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

NEXT_TOKEN=""
UPDATED=0
PAGE=0

while :; do
  # ── Page counter & message ─────────────
  PAGE=$((PAGE+1))
  echo "▶ Scanning page $PAGE..."

  # 1) Scan for up to $PAGE_SIZE items missing 'expiration' & matching filters
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --limit "$PAGE_SIZE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --limit "$PAGE_SIZE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If there’s nothing to update on this page, exit
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Update each record, track live count
  while read -r ID ACC; do
    ID=${ID//$'\r'/}
    ACC=${ACC//$'\r'/}

    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    ((UPDATED++))
    printf '\rRecords processed: %d' "$UPDATED"
  done <<< "$RAW_LIST"
  printf '\n'

  # 3) Get NextToken for the next page (same filters & limit)
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
      --limit "$PAGE_SIZE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID" \
      --query "NextToken" \
      --output text)

  # If no more pages remain, stop
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Final summary
if (( UPDATED > 0 )); then
  echo
  echo "Processed $PAGE pages, updated $UPDATED records."
fi
========================================================================================

#!/usr/bin/env bash
set -euo pipefail

# ── Configuration ─────────────
TABLE="test"
EXP_DAYS=60
PAGE_SIZE=1000              # max items to fetch per Scan “page”

# Filter values
BATCH_ID="yourBatchIdValue"
PCLM_TYPE="yourPclmTypeValue"

# Computes the expiration timestamp (UTC now + EXP_DAYS days)
EXPIRATION=$(date -u -d "+${EXP_DAYS} days" +%s)

# Tracks when we last refreshed credentials
LAST_REFRESH=0

# Function to refresh AWS STS session credentials (valid 1h)
refresh_credentials() {
  echo "⟳ Refreshing AWS session token…"
  # Fetch new temporary credentials and split them into three vars
  read AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN <<< \
    $(aws sts get-session-token \
         --duration-seconds 3600 \
         --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
         --output text)
  export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
  LAST_REFRESH=$(date +%s)
}

# Prime the initial session
refresh_credentials

NEXT_TOKEN=""
UPDATED=0
PAGE=0

while :; do
  # If it's been almost an hour, refresh before the next scan
  NOW=$(date +%s)
  if (( NOW - LAST_REFRESH > 3500 )); then
    refresh_credentials
  fi

  # Page counter & progress message
  PAGE=$((PAGE+1))
  echo "▶ Scanning page $PAGE..."

  # 1) Scan up to $PAGE_SIZE items missing 'expiration' & matching filters
  if [[ -n "$NEXT_TOKEN" ]]; then
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --limit "$PAGE_SIZE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text \
      --starting-token "$NEXT_TOKEN")
  else
    RAW_LIST=$(aws dynamodb scan \
      --table-name "$TABLE" \
      --limit "$PAGE_SIZE" \
      --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
      --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
      --projection-expression "ID,ACCOUNTNUMBER" \
      --query "Items[*].[ID.S,ACCOUNTNUMBER.S]" \
      --output text)
  fi

  # If no items on this page, we're done
  if [[ -z "$RAW_LIST" ]]; then
    echo "No items found without an expiration—nothing to update."
    break
  fi

  # 2) Update each item, show live counter
  while read -r ID ACC; do
    # strip stray carriage returns
    ID=${ID//$'\r'/}
    ACC=${ACC//$'\r'/}

    aws dynamodb update-item \
      --table-name "$TABLE" \
      --key "{\"ID\":{\"S\":\"$ID\"},\"ACCOUNTNUMBER\":{\"S\":\"$ACC\"}}" \
      --update-expression "SET expiration = :exp" \
      --expression-attribute-values "{\":exp\":{\"N\":\"$EXPIRATION\"}}" \
      --return-values NONE

    ((UPDATED++))
    printf '\rRecords processed: %d' "$UPDATED"
  done <<< "$RAW_LIST"
  printf '\n'

  # 3) Fetch NextToken (same filters & limit)
  NEXT_TOKEN=$(aws dynamodb scan \
    --table-name "$TABLE" \
    --limit "$PAGE_SIZE" \
    --filter-expression "attribute_not_exists(expiration) AND batchID = :batchID AND PCLMType = :pclmType" \
    --expression-attribute-values '{":batchID":{"S":"'"$BATCH_ID"'"},":pclmType":{"S":"'"$PCLM_TYPE"'"}}' \
    --projection-expression "ID" \
    --query "NextToken" \
    --output text)

  # If no more pages remain, exit
  [[ "$NEXT_TOKEN" == "None" || -z "$NEXT_TOKEN" ]] && break
done

# Final summary
if (( UPDATED > 0 )); then
  echo
  echo "Processed $PAGE pages, updated $UPDATED records."
fi


==========================

public class MaskUtil {

    public static String maskNumber(String number) {
        if (number == null || number.isEmpty()) return number;

        int len = number.length();

        // Handle short numbers
        if (len <= 2) {
            return number; // nothing to mask
        } else if (len == 3) {
            return number.charAt(0) + "*" + number.charAt(2);
        }

        // For longer numbers
        int prefixLen = Math.max(1, len / 3);
        int suffixLen = Math.max(1, len / 3);

        // Ensure we don't overlap
        if (prefixLen + suffixLen >= len) {
            prefixLen = 1;
            suffixLen = len - 2; // leave middle at least 1 char
        }

        String prefix = number.substring(0, prefixLen);
        String suffix = number.substring(len - suffixLen);

        return prefix + "***" + suffix;
    }

    public static void main(String[] args) {
        System.out.println(maskNumber("686123744"));       // 686***744
        System.out.println(maskNumber("7798123410"));      // 779***1410
        System.out.println(maskNumber("515291234555831")); // 51529***55831
        System.out.println(maskNumber("2040"));             // 2**0
        System.out.println(maskNumber("10000001234561769589")); // 1000000***1769589
        System.out.println(maskNumber("12"));               // 12
        System.out.println(maskNumber("123"));              // 1*3
    }
}




Masking rule (matches your photo)

Statement:

If the string length ≤ 2 → show as-is.

If length = 3 → show first and last, mask the middle with * → a*b.

Else (length ≥ 4):

maskLen = min(3, length - 2) // mask up to 3 middle digits, but always leave at least 1 at each end

visible = length - maskLen

prefixLen = visible // 2 (floor)

suffixLen = visible - prefixLen

Output = prefix + "*" * maskLen + suffix
✅ This preserves the original total length and yields patterns like your examples:
686***744, 779***1410, 51529***55831, 2**0, 1000000***1769589.

Table: how 1–20 digit accounts will display

(Using the sample original 123… up to the length shown)

Len	Shown
1	1
2	12
3	1*3
4	1**4
5	1***5
6	1***56
7	12***67
8	12***678
9	123***789
10	123***7890
11	1234***8901
12	1234***89012
13	12345***90123
14	12345***901234
15	123456***012345
16	123456***0123456
17	1234567***1234567
18	1234567***12345678
19	12345678***23456789
20	12345678***234567890


public final class MaskUtil {
    private MaskUtil() {}

    /** Masks the middle of the string with up to 3 asterisks, preserving total length. */
    public static String maskCentered(String number) {
        if (number == null) return null;
        int len = number.length();
        if (len <= 2) return number;               // nothing to mask
        if (len == 3) return number.charAt(0) + "*" + number.charAt(2);

        int maskLen = Math.min(3, len - 2);        // keep at least 1 at each end
        int visible = len - maskLen;
        int prefixLen = visible / 2;               // floor
        int suffixLen = visible - prefixLen;

        String prefix = number.substring(0, prefixLen);
        String suffix = number.substring(len - suffixLen);
        return prefix + "*".repeat(maskLen) + suffix;
    }
}


📝 Masking Rule Description (for your documentation)

Name: Center masking (proportional pattern)
Purpose: Hide the middle part of an account number while keeping both ends visible for recognition.

Rule:

If the number has 1–2 digits, show it as-is (no masking).

If the number has 3 digits, show the first and last digits and replace the middle digit with *.

Example: 123 → 1*3

If the number has 4 or more digits:

Keep at least one digit at the start and one digit at the end visible.

Replace the middle section (up to 3 digits) with asterisks (*).

The total length of the masked string must always equal the original length.

The number of visible digits at the start and at the end is proportional to the total length (roughly split in half around the masked part).

If the number is very long, keep more digits visible on each end, but still replace exactly 3 digits in the center with ***.

Examples:

Original	Masked
2	2
123	1*3
1234	1**4
686123744	686***744
7798123410	779***1410
51529123455831	51529***55831
10000001234561769589	1000000***1769589


🧠 One-sentence version

Show the first and last parts of the number and replace the center section (up to 3 digits) with asterisks, preserving the total length and making the visible parts proportional to the number’s length.

If you want, I can also give you a short math formula version of the rule (prefix length, mask length, suffix length) to include in your technical design doc.
Would you like me to do that?

You said:
what is the behavior with non-odd numbers?
ChatGPT said:

Great question ✅ — this is the subtle part that makes your pattern work consistently.

📐 How the rule behaves with even vs. odd lengths

Remember the logic:

Always mask up to 3 digits in the center (maskLen = min(3, len - 2))

Then split the remaining visible digits around the mask.

So:

visible = totalLength - maskLen
prefixLen = floor(visible / 2)
suffixLen = visible - prefixLen


This means:

If visible is even, it splits evenly between prefix and suffix.

If visible is odd, the extra digit goes to the suffix (end side).

📋 Examples
Total Length	MaskLen	Visible	PrefixLen	SuffixLen	Masked result
6 (even)	3	3	1	2	1***56
8 (even)	3	5	2	3	12***678
10 (even)	3	7	3	4	123***7890
7 (odd)	3	4	2	2	12***67
9 (odd)	3	6	3	3	123***789
11 (odd)	3	8	4	4	1234***8901

🔍 Notice how:

10 → 123***7890 has 3 on the left and 4 on the right

9 → 123***789 has 3 on the left and 3 on the right

So when the count of visible digits is odd, the suffix gets one more digit than the prefix.

🧠 One-line explanation

For even lengths, the visible digits are split equally around the mask;
for odd lengths, the extra visible digit is placed at the end (suffix side).



Center masking (proportional):
For lengths 1–2, show as-is. For 3, show the first and last digit, mask the middle with *. For 4+, mask the center with up to 3 asterisks (never more than the number of middle digits, and always leaving at least one visible digit on each end). The total length of the masked string equals the original. Distribute the visible digits around the mask proportionally; when the count of visible digits is odd, the extra visible digit goes to the end.


public final class MaskUtil {
    private MaskUtil() {}

    /** Masks the middle of the string with up to 3 asterisks, preserving total length. */
    public static String maskCentered(String number) {
        if (number == null) return null;
        int len = number.length();
        if (len <= 2) return number;               // nothing to mask
        if (len == 3) return number.charAt(0) + "*" + number.charAt(2);

        int maskLen = Math.min(3, len - 2);        // keep at least 1 at each end
        int visible = len - maskLen;
        int prefixLen = visible / 2;               // floor
        int suffixLen = visible - prefixLen;       // end gets the extra if odd

        String prefix = number.substring(0, prefixLen);
        String suffix = number.substring(len - suffixLen);
        return prefix + "*".repeat(maskLen) + suffix;
    }
}
